# План разработки WMOC SaaS Platform

## Текущий статус

### ✅ Реализовано

#### Инфраструктура
- [x] Docker Compose конфигурация для продакшена
- [x] PostgreSQL контейнер с оптимизированными настройками
- [x] Redis контейнер для кеша и сессий
- [x] Node.js API контейнер
- [x] Caddy reverse proxy на отдельном Alpine контейнере (192.168.100.101)
- [x] SSL/TLS через Let's Encrypt (автоматически)
- [x] Развёртывание на Ubuntu 24.04 (192.168.100.102)

#### Backend API
- [x] Базовая структура Express приложения
- [x] Подключение к PostgreSQL
- [x] Подключение к Redis
- [x] Система логирования (Winston)
- [x] Middleware для обработки ошибок
- [x] Health check endpoint

#### Аутентификация
- [x] Регистрация пользователей (`POST /api/auth/register`)
- [x] Вход пользователей (`POST /api/auth/login`)
- [x] JWT токены (access + refresh)
- [x] Middleware для проверки JWT (`src/middleware/auth.ts`)
- [ ] Обновление токенов (`POST /api/auth/refresh`)
- [ ] Выход (`POST /api/auth/logout`)

#### Управление контроллерами
- [x] Базовая структура маршрутов (`src/api/routes/controllers.ts`)
- [ ] Список контроллеров пользователя (`GET /api/controllers`)
- [ ] Активация нового контроллера (`POST /api/controllers/activate`)
- [ ] Информация о контроллере (`GET /api/controllers/:id`)
- [ ] Обновление метаданных (`PUT /api/controllers/:id`)
- [ ] Удаление контроллера (`DELETE /api/controllers/:id`)
- [ ] Отправка команд (`POST /api/controllers/:id/commands`)

#### WebSocket Tunnel Service
- [x] Базовая структура TunnelService (`src/tunnel/TunnelService.ts`)
- [x] WebSocket сервер на `/tunnel`
- [x] Управление подключениями контроллеров
- [ ] Регистрация контроллера через activation token
- [ ] Авторизация контроллера по сохранённым credentials
- [ ] HTTP reverse-proxy через WebSocket
- [ ] Маршрутизация запросов к контроллерам
- [ ] Управление жизненным циклом соединений

#### База данных
- [x] Схема миграций (`src/database/migrations/001_initial_schema.sql`)
- [x] Таблицы: `users`, `controllers`, `controller_sessions`, `notifications`, `metrics`
- [ ] Применение миграций в продакшене
- [ ] Seed данные для тестирования

#### Уведомления
- [x] Базовая структура сервиса (`src/services/notifications.ts`)
- [x] Маршруты (`src/api/routes/notifications.ts`)
- [ ] Реализация создания уведомлений
- [ ] Список уведомлений пользователя (`GET /api/notifications`)
- [ ] Отметка как прочитанное (`PUT /api/notifications/:id/read`)

#### Метрики
- [x] Базовая структура сервиса (`src/services/metrics.ts`)
- [x] Маршруты (`src/api/routes/metrics.ts`)
- [ ] Сохранение метрик от контроллеров
- [ ] Получение метрик (`GET /api/controllers/:id/metrics`)
- [ ] Агрегация и статистика

#### Статические страницы
- [x] Лендинг (`src/public/index.html`)
- [x] Страница регистрации (`src/public/register.html`)
- [x] Страница входа (`src/public/login.html`)
- [x] Интеграция с API для регистрации и входа

#### Документация
- [x] ARCHITECTURE.md - описание архитектуры
- [x] README.md - общая информация
- [x] DEPLOYMENT_PRODUCTION.md - полная инструкция по развёртыванию
- [x] QUICK_START_PRODUCTION.md - быстрый старт
- [x] CADDY_CONFIG_ALPINE.md - конфигурация Caddy

---

## Следующие шаги

### Приоритет 1: Завершение базового функционала

#### 1.1. Завершение API аутентификации
- [ ] Реализовать `POST /api/auth/refresh` для обновления токенов
- [ ] Реализовать `POST /api/auth/logout` для выхода
- [ ] Добавить проверку истечения токенов
- [ ] Тестирование всех сценариев авторизации

#### 1.2. Управление контроллерами (CRUD)
- [ ] Реализовать все endpoints из `src/api/routes/controllers.ts`:
  - `GET /api/controllers` - список контроллеров пользователя
  - `GET /api/controllers/:id` - информация о контроллере
  - `PUT /api/controllers/:id` - обновление метаданных (имя, описание)
  - `DELETE /api/controllers/:id` - удаление контроллера
- [ ] Добавить валидацию входных данных (Zod схемы)
- [ ] Проверка прав доступа (только владелец может управлять контроллером)
- [ ] Тестирование всех операций

#### 1.3. Активация контроллеров
- [ ] Реализовать `POST /api/controllers/activate`
- [ ] Генерация activation tokens
- [ ] Привязка контроллера к пользователю
- [ ] Валидация MAC-адреса
- [ ] Создание записей в таблице `controllers`

#### 1.4. WebSocket Tunnel Service
- [ ] Реализовать протокол регистрации контроллера:
  - Приём activation token от контроллера
  - Проверка токена и создание записи контроллера
  - Отправка credentials обратно контроллеру
- [ ] Реализовать протокол авторизации:
  - Проверка credentials (MAC + token)
  - Установка соединения
- [ ] Реализовать HTTP reverse-proxy:
  - Приём HTTP запросов от пользователей через API
  - Передача запросов контроллеру через WebSocket
  - Получение ответов и возврат пользователю
- [ ] Маршрутизация `/c/{controllerId}/*` → TunnelService
- [ ] Управление соединениями (подключение/отключение)
- [ ] Таймауты и обработка ошибок

#### 1.5. Применение миграций БД
- [ ] Создать скрипт для применения миграций
- [ ] Проверить и применить миграции в продакшене
- [ ] Документировать процесс миграций

### Приоритет 2: Frontend Portal (Личный кабинет)

#### 2.1. Выбор технологии
- [ ] Решить: React + Next.js или простой HTML/JS?
- [ ] Настроить проект frontend

#### 2.2. Авторизация
- [ ] Страница входа (уже есть базовая версия)
- [ ] Страница регистрации (уже есть базовая версия)
- [ ] Хранение токенов (localStorage/sessionStorage)
- [ ] Автоматическое обновление токенов
- [ ] Редирект неавторизованных пользователей

#### 2.3. Дашборд (главная страница)
- [ ] Список контроллеров пользователя
- [ ] Статус каждого контроллера (онлайн/офлайн)
- [ ] Последнее время подключения
- [ ] Быстрые действия (переход к интерфейсу контроллера)

#### 2.4. Управление контроллерами
- [ ] Страница списка контроллеров
- [ ] Страница активации нового контроллера
- [ ] Страница настроек контроллера (изменение имени, удаление)
- [ ] Интеграция с API endpoints

#### 2.5. Доступ к интерфейсу контроллера
- [ ] Проксирование веб-интерфейса контроллера через `/c/{controllerId}/*`
- [ ] Отображение в iframe или отдельной странице
- [ ] Обработка ошибок (контроллер офлайн)

#### 2.6. Мониторинг и статистика
- [ ] Графики метрик (температура, статусы)
- [ ] История подключений
- [ ] Уведомления

### Приоритет 3: Дополнительный функционал

#### 3.1. Уведомления
- [ ] Полная реализация сервиса уведомлений
- [ ] Создание уведомлений при событиях:
  - Контроллер подключился/отключился
  - Критические события (высокая температура и т.д.)
  - Обновления прошивки
- [ ] API endpoints для получения и отметки уведомлений
- [ ] Frontend интеграция

#### 3.2. Метрики
- [ ] Полная реализация сервиса метрик
- [ ] Приём метрик от контроллеров
- [ ] Хранение в БД
- [ ] API для получения метрик
- [ ] Агрегация и статистика
- [ ] Frontend графики

#### 3.3. Команды контроллерам
- [ ] API endpoint `POST /api/controllers/:id/commands`
- [ ] Передача команд через WebSocket туннель
- [ ] Очередь команд
- [ ] Подтверждение выполнения

#### 3.4. Логирование
- [ ] Централизованное логирование всех событий
- [ ] Логи контроллеров
- [ ] API для получения логов
- [ ] Ротация логов

### Приоритет 4: Безопасность и оптимизация

#### 4.1. Безопасность
- [ ] Rate limiting на API endpoints
- [ ] Валидация всех входных данных
- [ ] Защита от SQL injection (уже есть через параметризованные запросы)
- [ ] CORS настройки
- [ ] Защита от XSS
- [ ] Защита от CSRF (для форм)

#### 4.2. Производительность
- [ ] Connection pooling для PostgreSQL
- [ ] Кеширование частых запросов (Redis)
- [ ] Оптимизация SQL запросов
- [ ] Индексы в БД

#### 4.3. Мониторинг
- [ ] Health checks для всех сервисов
- [ ] Метрики производительности
- [ ] Алерты при проблемах

### Приоритет 5: Расширенный функционал (будущее)

#### 5.1. Подписки
- [ ] Тарифы (free, basic, premium)
- [ ] Ограничения по количеству контроллеров
- [ ] Проверка лимитов при активации
- [ ] Страница управления подпиской

#### 5.2. Мультитенантность
- [ ] Поддержка нескольких пользователей
- [ ] Изоляция данных между пользователями
- [ ] Административная панель

#### 5.3. Масштабирование
- [ ] Горизонтальное масштабирование API
- [ ] Load balancer
- [ ] Read replicas для PostgreSQL
- [ ] Кластеризация Redis

---

## Технические детали

### Протокол WebSocket Tunnel

#### Регистрация контроллера (первое подключение)
```json
// Контроллер → Сервер
{
  "type": "register",
  "token": "activation_token_from_api",
  "mac": "AA:BB:CC:DD:EE:FF",
  "firmware_version": "1.0.0"
}

// Сервер → Контроллер
{
  "type": "registered",
  "controllerId": "uuid",
  "credentials": {
    "mac": "AA:BB:CC:DD:EE:FF",
    "token": "saved_token"
  },
  "status": "active"
}
```

#### Подключение с credentials
```json
// Контроллер → Сервер
{
  "type": "auth",
  "mac": "AA:BB:CC:DD:EE:FF",
  "token": "saved_token"
}

// Сервер → Контроллер
{
  "type": "authenticated",
  "controllerId": "uuid",
  "status": "active"
}
```

#### HTTP запрос через туннель
```json
// Сервер → Контроллер (HTTP запрос от пользователя)
{
  "type": "http_request",
  "id": "request_id",
  "method": "GET",
  "path": "/api/status",
  "headers": {
    "Host": "controller.local",
    "Authorization": "Basic ..."
  },
  "body": ""
}

// Контроллер → Сервер (HTTP ответ)
{
  "type": "http_response",
  "id": "request_id",
  "status": 200,
  "headers": {
    "Content-Type": "application/json"
  },
  "body": "{...}"
}
```

### Структура базы данных

См. `src/database/migrations/001_initial_schema.sql` для полной схемы.

Основные таблицы:
- `users` - пользователи платформы
- `controllers` - зарегистрированные контроллеры
- `controller_sessions` - активные WebSocket соединения
- `notifications` - уведомления пользователям
- `metrics` - метрики от контроллеров

---

## Заметки по разработке

### Порядок разработки

1. **Сначала Backend API** - все endpoints должны быть готовы и протестированы
2. **Затем WebSocket Tunnel** - интеграция с API для управления контроллерами
3. **Frontend Portal** - использует готовый Backend API
4. **Дополнительный функционал** - уведомления, метрики, логи

### Тестирование

- Unit тесты для сервисов
- Integration тесты для API endpoints
- E2E тесты для критических сценариев
- Тестирование WebSocket соединений

### Деплой

- Все изменения сначала тестируются локально
- Затем на тестовом окружении (если есть)
- Только потом на продакшен
- Использовать feature branches и pull requests

